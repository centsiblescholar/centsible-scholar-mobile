---
phase: 05-iap-wiring
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/hooks/useRevenueCatPurchase.ts
  - app/paywall.tsx
  - app/manage-subscription.tsx
autonomous: true

must_haves:
  truths:
    - "User can initiate a real purchase through RevenueCat on the paywall screen"
    - "After purchase succeeds on store side, app polls Supabase until webhook confirms subscription"
    - "User sees processing state during polling with a clear pending message"
    - "If polling times out (60s), user sees a helpful message to check back later"
    - "User can restore purchases via RevenueCat restorePurchases API"
    - "Cancelled purchases are handled gracefully without error alerts"
    - "Web subscribers (platform === 'stripe') see 'Already subscribed via web' message instead of purchase buttons"
    - "Manage subscription screen uses the same real purchase flow for plan switches"
  artifacts:
    - path: "src/hooks/useRevenueCatPurchase.ts"
      provides: "Purchase mutation hook with RevenueCat purchasePackage and Supabase polling"
      exports: ["useRevenueCatPurchase"]
      min_lines: 60
    - path: "app/paywall.tsx"
      provides: "Paywall wired to real RevenueCat purchase flow with web subscriber guard"
      contains: "useRevenueCatPurchase"
    - path: "app/manage-subscription.tsx"
      provides: "Manage subscription wired to real RevenueCat purchase flow"
      contains: "useRevenueCatPurchase"
  key_links:
    - from: "src/hooks/useRevenueCatPurchase.ts"
      to: "react-native-purchases"
      via: "Purchases.getOfferings() and Purchases.purchasePackage()"
      pattern: "Purchases\\.purchasePackage"
    - from: "src/hooks/useRevenueCatPurchase.ts"
      to: "user_subscriptions table"
      via: "Supabase polling for webhook confirmation"
      pattern: "pollForWebhookConfirmation"
    - from: "app/paywall.tsx"
      to: "src/hooks/useRevenueCatPurchase.ts"
      via: "import useRevenueCatPurchase"
      pattern: "useRevenueCatPurchase"
    - from: "app/paywall.tsx"
      to: "src/hooks/useSubscriptionStatus.ts"
      via: "platform check for web subscriber guard"
      pattern: "useSubscriptionStatus"
---

<objective>
Create the real purchase hook using RevenueCat SDK, implement webhook polling confirmation, and wire it into the paywall and manage-subscription screens replacing the mock purchase flow.

Purpose: This is the core purchase flow -- the user taps "Start Free Trial" and money actually flows through Apple/Google. The app waits for the webhook to confirm before unlocking features (no optimistic unlocking per CONTEXT.md).
Output: Working purchase hook, paywall with real IAP, manage-subscription with real plan switching, web subscriber guard.
</objective>

<execution_context>
@/Users/robertisrael/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robertisrael/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-iap-wiring/05-CONTEXT.md
@.planning/phases/05-iap-wiring/05-RESEARCH.md
@.planning/phases/05-iap-wiring/05-01-SUMMARY.md
@src/hooks/useMockPurchase.ts
@src/hooks/useSubscriptionStatus.ts
@src/constants/subscriptionPlans.ts
@src/constants/revenuecatConfig.ts
@app/paywall.tsx
@app/manage-subscription.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useRevenueCatPurchase hook with polling confirmation</name>
  <files>
    src/hooks/useRevenueCatPurchase.ts
  </files>
  <action>
Create `src/hooks/useRevenueCatPurchase.ts` that replaces `useMockPurchase` with the same interface but real RevenueCat purchase flow.

**Interface (must match useMockPurchase for drop-in replacement):**
```typescript
export interface PurchaseInput {
  plan: 'single' | 'midsize' | 'large';
  billingInterval: 'month' | 'year';
}

// Return type must match useMockPurchase:
// { purchase: (input) => Promise<...>, isPurchasing: boolean, purchaseError: Error | null }
```

**Implementation:**

1. Import `Purchases, PurchasesError` from `react-native-purchases`
2. Import `REVENUECAT_CONFIG` from `../constants/revenuecatConfig`
3. Import `supabase` from `../integrations/supabase/client`
4. Import `useAuth` from `../contexts/AuthContext`
5. Import `useMutation, useQueryClient` from `@tanstack/react-query`
6. Import `subscriptionKeys` from `./useSubscriptionStatus`
7. Import `SUBSCRIPTION_PLANS` from `../constants/subscriptionPlans`

**pollForWebhookConfirmation(userId: string): Promise<boolean>**
- Loop with `REVENUECAT_CONFIG.polling.intervalMs` between iterations
- Check `REVENUECAT_CONFIG.polling.timeoutMs` for total elapsed
- Each iteration: query `user_subscriptions` for `user_id = userId` with `status IN ('active', 'trialing')` and `platform IN ('apple', 'google')`
- Use `.maybeSingle()` -- if data found, return `true`
- If timeout reached, return `false`
- Use `await new Promise(resolve => setTimeout(resolve, intervalMs))` between polls

**useMutation mutationFn(input: PurchaseInput):**
1. Validate user is authenticated
2. Look up the plan from `SUBSCRIPTION_PLANS` by `input.plan`
3. Get offerings via `Purchases.getOfferings()`
4. If no `offerings.current`, throw `'No offerings available'`
5. Find the correct package: look for the plan's `rcPackageId[input.billingInterval]` in `offerings.current.availablePackages` by matching `package.identifier`
6. If package not found, fall back to searching by product ID: match `package.product.identifier` against the platform-specific product ID from `subscriptionPlans`
7. If still not found, throw descriptive error with available package IDs for debugging
8. Call `Purchases.purchasePackage(pkg)` wrapped in try/catch:
   - If `error.userCancelled` is true, throw `new Error('Purchase cancelled')` (user dismissed the store dialog)
   - Otherwise re-throw the error
9. After successful purchase, call `pollForWebhookConfirmation(user.id)`
10. If polling returns `false` (timeout), throw `new Error('PURCHASE_PENDING')` -- this is a special error the UI handles differently
11. Return `{ confirmed: true }`

**onSuccess callback:**
- `queryClient.invalidateQueries({ queryKey: subscriptionKeys.all })` -- forces subscription status to re-fetch

**Also export a `useRestorePurchases` hook:**
- Calls `Purchases.restorePurchases()`
- Then polls Supabase for webhook confirmation (same `pollForWebhookConfirmation`)
- Returns `{ restore, isRestoring, restoreError }`

Do NOT check RevenueCat entitlements directly. Do NOT optimistically unlock features. The app waits for the webhook to update Supabase.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `src/hooks/useRevenueCatPurchase.ts` exports `useRevenueCatPurchase` and `useRestorePurchases`
    - Hook returns `{ purchase, isPurchasing, purchaseError }` matching useMockPurchase interface
    - Contains `pollForWebhookConfirmation` function
    - Contains `Purchases.purchasePackage` call
    - Contains `Purchases.restorePurchases` call
    - Does NOT contain `Purchases.getCustomerInfo()` or direct entitlement checks
  </verify>
  <done>
    Purchase hook makes real RevenueCat purchases and polls Supabase for webhook confirmation before reporting success. Restore hook uses RevenueCat restore API with the same polling pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire paywall and manage-subscription to real purchase flow</name>
  <files>
    app/paywall.tsx
    app/manage-subscription.tsx
  </files>
  <action>
**Update `app/paywall.tsx`:**

1. Replace `import { useMockPurchase }` with `import { useRevenueCatPurchase, useRestorePurchases }` from `../src/hooks/useRevenueCatPurchase`
2. Add `import { useSubscriptionStatus } from '../src/hooks/useSubscriptionStatus'`
3. Replace `const { purchase, isPurchasing } = useMockPurchase()` with `const { purchase, isPurchasing, purchaseError } = useRevenueCatPurchase()` and `const { restore, isRestoring } = useRestorePurchases()`
4. Add `const { platform, isActive } = useSubscriptionStatus()`

5. **Web subscriber guard:** At the top of the screen content (before plan cards), add a check:
   - If `isActive && platform === 'stripe'`, show a card with:
     - Ionicons `information-circle-outline` icon
     - "Already Subscribed via Web" heading
     - "Your subscription is managed through the website. To change your plan, please visit centsiblescholar.com." message
     - Do NOT show plan cards or purchase buttons in this case
   - Return early (don't render plan cards)

6. **Update handlePurchase:**
   - Keep the same flow but handle the `PURCHASE_PENDING` error specially:
     - If `error.message === 'PURCHASE_PENDING'`, show Alert: "Purchase Processing", "Your purchase was successful but is still being confirmed. This usually takes a few seconds. If your subscription isn't active in a few minutes, try pulling down to refresh."
     - If `error.message === 'Purchase cancelled'`, do NOT show an alert (user intentionally cancelled)
     - Other errors: show the existing error alert
   - On success: change alert to "Welcome!" / "Your subscription is now active." (not "free trial started" since it might be a direct purchase)

7. **Update handleRestore:**
   - Replace the entire mock restore logic with:
     ```
     const { restore } = useRestorePurchases();
     ```
   - In handleRestore:
     - Call `await restore()`
     - On success, show "Restored!" alert and `router.replace('/')`
     - On error, show "No Purchases Found" or "Unable to restore" depending on error type
   - Remove the manual Supabase query and simulated delay

8. Remove the `import { supabase }` if no longer used (check if any other code in the file uses it).

**Update `app/manage-subscription.tsx`:**

1. Replace `import { useMockPurchase }` with `import { useRevenueCatPurchase }` from `../src/hooks/useRevenueCatPurchase`
2. Replace `const { purchase, isPurchasing } = useMockPurchase()` with `const { purchase, isPurchasing } = useRevenueCatPurchase()`
3. The rest of the manage-subscription logic (handleSwitchPlan, handleCancelSubscription) stays the same since the interface is identical
4. In handleSwitchPlan, add the same `PURCHASE_PENDING` error handling as the paywall

Do NOT modify the visual design of either screen. Only swap the purchase hooks and add the web subscriber guard.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `app/paywall.tsx` imports from `useRevenueCatPurchase` (not `useMockPurchase`)
    - `app/manage-subscription.tsx` imports from `useRevenueCatPurchase` (not `useMockPurchase`)
    - `app/paywall.tsx` contains web subscriber guard checking `platform === 'stripe'`
    - No remaining imports of `useMockPurchase` in either file
    - `PURCHASE_PENDING` error is handled specially (not shown as a generic error)
    - Cancelled purchases do not show error alerts
  </verify>
  <done>
    Paywall and manage-subscription screens use real RevenueCat purchases instead of mock. Web subscribers see "Already Subscribed via Web" message. Purchase pending and cancellation states are handled gracefully.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` compiles without errors
- `grep -r "useMockPurchase" app/` returns NO results (fully replaced)
- `app/paywall.tsx` uses `useRevenueCatPurchase` and has web subscriber guard
- `app/manage-subscription.tsx` uses `useRevenueCatPurchase`
- Purchase hook polls Supabase (not RevenueCat entitlements) for confirmation
- Restore uses `Purchases.restorePurchases()` with polling
</verification>

<success_criteria>
- Real RevenueCat purchases work through the paywall (purchasePackage called with correct offering/package)
- App waits for webhook confirmation via Supabase polling before unlocking features
- Polling timeout (60s) shows a user-friendly "still processing" message
- Cancelled purchases are silently handled (no error alert)
- Web subscribers see "Already Subscribed via Web" instead of purchase buttons
- Restore purchases uses RevenueCat API with webhook polling confirmation
- Manage subscription plan switching uses the same real purchase flow
- useMockPurchase is no longer imported by any screen
</success_criteria>

<output>
After completion, create `.planning/phases/05-iap-wiring/05-03-SUMMARY.md`
</output>
