---
phase: 01-architecture-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useSubscriptionStatus.ts
  - supabase/migrations/20260205_add_iap_subscription_columns.sql
autonomous: true

must_haves:
  truths:
    - "Subscription status can be checked without knowing whether the user subscribed via Stripe or IAP"
    - "useSubscriptionStatus returns { isActive, tier, status, periodEnd } regardless of payment source"
    - "Existing subscription queries continue to work for Stripe-only users"
    - "No subscription returns isActive as null (not false) to distinguish from query failure"
    - "The subscription schema supports tracking platform source (stripe/apple/google)"
  artifacts:
    - path: "src/hooks/useSubscriptionStatus.ts"
      provides: "Platform-agnostic subscription status hook"
      exports: ["useSubscriptionStatus", "subscriptionKeys", "SubscriptionStatus"]
      contains: "platform"
    - path: "supabase/migrations/20260205_add_iap_subscription_columns.sql"
      provides: "SQL migration adding IAP columns to user_subscriptions"
      contains: "ALTER TABLE"
  key_links:
    - from: "src/hooks/useSubscriptionStatus.ts"
      to: "supabase.from('user_subscriptions')"
      via: "React Query fetch"
      pattern: "from.*user_subscriptions"
    - from: "src/hooks/useSubscriptionStatus.ts"
      to: "src/contexts/AuthContext.tsx"
      via: "useAuth() for user.id"
      pattern: "useAuth"
---

<objective>
Create a SQL migration extending user_subscriptions for IAP support and refactor useSubscriptionStatus to be platform-agnostic, so downstream phases can check subscription status without knowing the payment source.

Purpose: The existing subscription system is Stripe-specific. Phase 4 (Subscription UI + Gates) and Phase 5 (IAP Wiring) need a unified subscription layer. This plan creates the schema and abstraction layer they depend on.

Output: A SQL migration file adding IAP columns to user_subscriptions, and a refactored useSubscriptionStatus hook that returns a platform-agnostic API.
</objective>

<execution_context>
@/Users/robertisrael/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robertisrael/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-architecture-foundation/01-CONTEXT.md
@src/hooks/useSubscriptionStatus.ts
@src/integrations/supabase/types.ts
@app/(tabs)/settings.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQL migration for IAP subscription columns</name>
  <files>supabase/migrations/20260205_add_iap_subscription_columns.sql</files>
  <action>
Create the migrations directory if it doesn't exist: `supabase/migrations/`

Create a SQL migration file that extends the existing `user_subscriptions` table to support IAP:

```sql
-- Add platform source tracking and IAP fields to user_subscriptions
-- Extends existing Stripe-only table to support Apple IAP and Google Play Billing

-- Platform source: where this subscription originated
-- 'stripe' for web subscriptions, 'apple' for App Store, 'google' for Google Play
ALTER TABLE user_subscriptions
ADD COLUMN IF NOT EXISTS platform TEXT NOT NULL DEFAULT 'stripe'
CHECK (platform IN ('stripe', 'apple', 'google'));

-- IAP-specific fields (null for Stripe subscriptions)
-- The product identifier from Apple/Google (e.g., 'com.centsiblescholar.premium.monthly')
ALTER TABLE user_subscriptions
ADD COLUMN IF NOT EXISTS iap_product_id TEXT;

-- The original transaction ID from the store (for receipt validation and deduplication)
ALTER TABLE user_subscriptions
ADD COLUMN IF NOT EXISTS iap_original_transaction_id TEXT;

-- RevenueCat customer ID (links to RevenueCat's customer record)
ALTER TABLE user_subscriptions
ADD COLUMN IF NOT EXISTS revenucat_customer_id TEXT;

-- Create index on platform for filtered queries
CREATE INDEX IF NOT EXISTS idx_user_subscriptions_platform
ON user_subscriptions (platform);

-- Create index on iap_original_transaction_id for deduplication lookups
CREATE INDEX IF NOT EXISTS idx_user_subscriptions_iap_txn
ON user_subscriptions (iap_original_transaction_id)
WHERE iap_original_transaction_id IS NOT NULL;

-- Comment on new columns for documentation
COMMENT ON COLUMN user_subscriptions.platform IS 'Payment platform: stripe, apple, or google';
COMMENT ON COLUMN user_subscriptions.iap_product_id IS 'App Store / Google Play product ID (null for Stripe)';
COMMENT ON COLUMN user_subscriptions.iap_original_transaction_id IS 'Original transaction ID from store (null for Stripe)';
COMMENT ON COLUMN user_subscriptions.revenucat_customer_id IS 'RevenueCat customer ID for IAP management (null for Stripe)';
```

Design decisions (from CONTEXT.md -- extend existing table rather than create separate):
- Extend `user_subscriptions` with new columns rather than creating a separate `iap_subscriptions` table. Reasoning: one subscription per user means a single table with platform-conditional columns is simpler for queries. The hook just reads the active record regardless of platform.
- Default platform to 'stripe' so all existing records automatically get the correct value with zero data migration.
- IAP columns are nullable because Stripe subscriptions don't need them.
- RevenueCat customer ID is stored to enable webhook correlation in Phase 5.

IMPORTANT: This is a migration FILE only. It documents the schema change. The actual migration will be run against Supabase separately (either via Supabase CLI or Dashboard SQL editor). The executor should create the file but note in the summary that it needs to be applied.
  </action>
  <verify>
Verify the SQL file exists at `supabase/migrations/20260205_add_iap_subscription_columns.sql`.
Verify the SQL syntax is valid by reading the file and confirming proper ALTER TABLE statements.
Confirm all 4 new columns are present: platform, iap_product_id, iap_original_transaction_id, revenucat_customer_id.
  </verify>
  <done>
SQL migration file exists with ALTER TABLE statements adding platform, iap_product_id, iap_original_transaction_id, and revenucat_customer_id columns to user_subscriptions. Existing Stripe rows default to platform='stripe'.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor useSubscriptionStatus to be platform-agnostic</name>
  <files>src/hooks/useSubscriptionStatus.ts</files>
  <action>
Refactor the existing useSubscriptionStatus hook to abstract away platform-specific details:

1. **Update the SubscriptionStatus interface** to be platform-agnostic:
   ```typescript
   export interface SubscriptionStatus {
     id: number;
     user_id: string;
     status: string;
     subscription_type: string;  // 'single' | 'midsize' | 'large'
     current_period_end: string | null;
     current_period_start: string | null;
     platform: 'stripe' | 'apple' | 'google';
     // Stripe-specific (null for IAP)
     stripe_customer_id: string | null;
     stripe_subscription_id: string | null;
     // IAP-specific (null for Stripe)
     iap_product_id: string | null;
     iap_original_transaction_id: string | null;
     revenucat_customer_id: string | null;
   }
   ```

2. **Update the fetchSubscriptionStatus function.** The query changes:
   - Select the active subscription record by user_id. Since we enforce one subscription per user, query for a single record:
     ```typescript
     const { data, error } = await supabase
       .from('user_subscriptions')
       .select('*')
       .eq('user_id', userId)
       .in('status', ['active', 'trialing'])
       .maybeSingle();
     ```
   - If no active/trialing record found, try to find any record (for canceled/past_due status display):
     ```typescript
     if (!data) {
       const { data: anyRecord, error: fallbackError } = await supabase
         .from('user_subscriptions')
         .select('*')
         .eq('user_id', userId)
         .order('updated_at', { ascending: false })
         .limit(1)
         .maybeSingle();
       if (fallbackError) throw fallbackError;
       return anyRecord;
     }
     ```
   - This ensures the hook returns the most relevant subscription record.

3. **Update the return values** to provide a clean, platform-agnostic API:
   ```typescript
   // The key change: isActive is null when there's no subscription record at all
   // This distinguishes "no subscription" from "subscription query failed" (which throws)
   const isActive = subscription
     ? (subscription.status === 'active' || subscription.status === 'trialing')
     : null;

   return {
     // Raw data
     subscription,
     isLoading,
     error,
     refetch,
     // Platform-agnostic accessors (the public API)
     isActive,                    // true | false | null (null = no subscription)
     tier: subscription?.subscription_type || null,  // 'single' | 'midsize' | 'large' | null
     status: subscription?.status || null,            // 'active' | 'trialing' | 'canceled' | etc | null
     periodEnd: subscription?.current_period_end || null,
     platform: subscription?.platform || null,        // 'stripe' | 'apple' | 'google' | null
     // Display helpers (keep for backward compatibility)
     subscriptionType: subscription?.subscription_type || 'none',
     subscriptionTypeDisplay: subscription?.subscription_type
       ? formatSubscriptionType(subscription.subscription_type)
       : 'None',
     periodEndDate,
   };
   ```

4. **Key changes from current implementation:**
   - `isActive` returns `null` instead of `false` when no subscription record exists (CONTEXT.md decision)
   - New `tier` field maps to subscription_type
   - New `platform` field exposes the payment source
   - `status` returns `null` instead of `'inactive'` when no subscription
   - Kept `subscriptionType`, `subscriptionTypeDisplay`, `periodEndDate` for backward compatibility with Settings screen

5. **Update formatSubscriptionType** mapping to match current naming:
   - 'single' -> 'Standard'
   - 'midsize' -> 'Premium'
   - 'large' -> 'Family' (changed from 'Enterprise' to match App Store tier naming from REQUIREMENTS.md SUB-01)

IMPORTANT: The Settings screen (`app/(tabs)/settings.tsx`) uses `isActive`, `subscriptionTypeDisplay`, `status`, `periodEndDate`, and `refetch`. All these fields must remain in the return value. The change from `isActive: false` to `isActive: null` for no-subscription requires verifying Settings handles this. In Settings, `isActive` is used in `getStatusColor()` which checks truthiness, so `null` and `false` both go to the red/default branch. This is safe.

IMPORTANT: Do NOT update `src/integrations/supabase/types.ts`. That file is auto-generated by Supabase CLI. After the migration is applied and types regenerated, it will automatically include the new columns. For now, the `select('*')` query will return whatever columns exist in the table.
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root.
Verify that the hook returns tier, platform, and that isActive can be null.
Check that Settings screen still references valid return fields from the hook.
  </verify>
  <done>
useSubscriptionStatus returns platform-agnostic API: isActive (true/false/null), tier, status, periodEnd, platform. No subscription = null (not false). Backward-compatible fields preserved for Settings screen. SQL migration file documents schema extension for IAP columns.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. SQL migration file exists at `supabase/migrations/20260205_add_iap_subscription_columns.sql`
3. useSubscriptionStatus interface includes platform, iap_product_id, iap_original_transaction_id, revenucat_customer_id
4. Hook returns isActive as null (not false) when no subscription exists
5. Hook returns tier, platform as new accessor fields
6. Settings screen subscription display still works (backward-compatible fields preserved)
7. formatSubscriptionType maps 'large' to 'Family' (not 'Enterprise')
</verification>

<success_criteria>
- SQL migration adds 4 new columns to user_subscriptions (platform, iap_product_id, iap_original_transaction_id, revenucat_customer_id)
- Existing Stripe subscriptions default to platform='stripe' with no data migration needed
- useSubscriptionStatus hook is platform-agnostic -- callers never need to know Stripe vs IAP
- isActive: null distinguishes "no subscription" from "inactive subscription"
- Settings screen subscription section works without modification
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-architecture-foundation/01-02-SUMMARY.md`
</output>
