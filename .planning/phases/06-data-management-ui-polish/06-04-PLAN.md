---
phase: 06-data-management-ui-polish
plan: 04
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - app/(tabs)/dashboard.tsx
  - app/(tabs)/grades.tsx
  - app/(tabs)/behavior.tsx
  - app/(tabs)/earnings.tsx
  - app/(tabs)/learn.tsx
  - app/(tabs)/daily.tsx
  - app/(tabs)/settings.tsx
  - app/(tabs)/_layout.tsx
  - app/_layout.tsx
  - app/(auth)/login.tsx
  - app/(auth)/signup.tsx
  - app/(auth)/forgot-password.tsx
  - app/(auth)/verify-reset-code.tsx
  - app/(auth)/_layout.tsx
  - app/edit-profile.tsx
  - app/paywall.tsx
  - app/manage-subscription.tsx
  - app/student-management.tsx
  - app/grade-approval.tsx
  - app/term-tracking.tsx
  - app/family-meetings.tsx
  - app/data-export.tsx
  - app/delete-account.tsx
  - app/(onboarding)/welcome.tsx
  - app/(onboarding)/profile.tsx
  - app/(onboarding)/how-it-works.tsx
  - app/(onboarding)/celebration.tsx
  - app/(onboarding)/_layout.tsx
  - src/components/daily/QODStep.tsx
  - src/components/daily/BehaviorStep.tsx
  - src/components/daily/CompletionCelebration.tsx
autonomous: true

must_haves:
  truths:
    - "All screens use colors from useTheme() hook, not hardcoded hex values"
    - "Tab bar and header colors come from theme, not hardcoded #4F46E5"
    - "Every data-fetching screen shows skeleton loading state instead of ActivityIndicator"
    - "Every data-fetching screen shows EmptyState component when no data"
    - "Every data-fetching screen shows ErrorState with retry button on fetch errors"
    - "All interactive elements have 44pt minimum touch targets"
    - "ThemeProvider wraps the entire app in root _layout.tsx"
  artifacts:
    - path: "app/_layout.tsx"
      provides: "Root layout with ThemeProvider wrapping all content"
      contains: "ThemeProvider"
    - path: "app/(tabs)/_layout.tsx"
      provides: "Tab layout using theme colors for tab bar"
      contains: "useTheme"
    - path: "app/(tabs)/dashboard.tsx"
      provides: "Dashboard with skeleton loading, empty state, error state, themed colors"
      contains: "useTheme"
  key_links:
    - from: "app/_layout.tsx"
      to: "src/theme/ThemeContext.tsx"
      via: "ThemeProvider wrapping app tree"
      pattern: "ThemeProvider"
    - from: "app/(tabs)/_layout.tsx"
      to: "src/theme/ThemeContext.tsx"
      via: "useTheme for tab bar colors"
      pattern: "useTheme.*tabActive.*tabInactive"
    - from: "app/(tabs)/dashboard.tsx"
      to: "src/components/ui/SkeletonCard.tsx"
      via: "DashboardSkeleton for loading state"
      pattern: "DashboardSkeleton|SkeletonCard"
---

<objective>
Migrate all screens to use the theme system (useTheme hook), add ThemeProvider to app layout, replace all loading spinners with skeleton screens, and add proper empty/error states to every data-fetching screen.

Purpose: Eliminates ~660 hardcoded color values, ensures dark mode readiness, and gives every screen polished loading/error/empty states worthy of App Store review.

Output: All 25+ screen files use theme tokens. Every data-fetching screen has skeleton loading, empty state, and error state with retry. ThemeProvider wraps the app. 44pt touch targets throughout.
</objective>

<execution_context>
@/Users/robertisrael/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robertisrael/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-data-management-ui-polish/06-CONTEXT.md
@.planning/phases/06-data-management-ui-polish/06-RESEARCH.md
@.planning/phases/06-data-management-ui-polish/06-01-SUMMARY.md
@src/theme/colors.ts
@src/theme/index.ts
@src/theme/ThemeContext.tsx
@src/theme/commonStyles.ts
@src/components/ui/SkeletonCard.tsx
@src/components/ui/EmptyState.tsx
@src/components/ui/ErrorState.tsx
@app/_layout.tsx
@app/(tabs)/_layout.tsx
@app/(tabs)/settings.tsx
@app/(tabs)/dashboard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire ThemeProvider into app + migrate layout files and tab screens to useTheme</name>
  <files>
    app/_layout.tsx
    app/(tabs)/_layout.tsx
    app/(auth)/_layout.tsx
    app/(onboarding)/_layout.tsx
    app/(tabs)/dashboard.tsx
    app/(tabs)/grades.tsx
    app/(tabs)/behavior.tsx
    app/(tabs)/earnings.tsx
    app/(tabs)/learn.tsx
    app/(tabs)/daily.tsx
    app/(tabs)/settings.tsx
  </files>
  <action>
    **1. Wire ThemeProvider into `app/_layout.tsx`:**
    - Import `ThemeProvider` from `@/theme`
    - Wrap inside QueryClientProvider > AuthProvider > RevenueCatProvider > **ThemeProvider** > StudentProvider
    - Place ThemeProvider inside AuthProvider (needs auth context) but outside StudentProvider
    - For the Stack screenOptions headerStyle, the colors need to come from the theme. Since _layout.tsx is a component, create a nested component `RootNavigator` that uses `useTheme()` to get colors and renders the Stack:
      ```tsx
      function RootNavigator() {
        const { colors } = useTheme();
        return (
          <Stack screenOptions={{
            headerStyle: { backgroundColor: colors.primary },
            headerTintColor: colors.textInverse,
            headerTitleStyle: { fontWeight: 'bold' },
          }}>
            {/* all Stack.Screen entries */}
          </Stack>
        );
      }
      ```
    - Keep StatusBar component

    **2. Migrate `app/(tabs)/_layout.tsx`:**
    - Import `useTheme` from `@/theme`
    - Replace all hardcoded hex colors:
      - `#4F46E5` -> `colors.tabActive` / `colors.primary`
      - `#9CA3AF` -> `colors.tabInactive`
      - `#fff` -> `colors.textInverse`
    - Use `const { colors } = useTheme();` at top of component

    **3. Migrate `app/(auth)/_layout.tsx` and `app/(onboarding)/_layout.tsx`:**
    - Same pattern: import useTheme, replace hardcoded colors with theme tokens

    **4. Migrate all 7 tab screens to useTheme + add loading/empty/error states:**

    For EACH tab screen (dashboard, grades, behavior, earnings, learn, daily, settings):

    a. **Import and use theme:**
       - Add `import { useTheme } from '@/theme';`
       - Add `const { colors } = useTheme();` at top of component
       - Replace ALL hardcoded hex colors in StyleSheet.create and inline styles:
         - `#4F46E5` -> `colors.primary`
         - `#EEF2FF` -> `colors.primaryLight`
         - `#F3F4F6` -> `colors.backgroundSecondary`
         - `#fff` / `#ffffff` -> `colors.background` or `colors.card`
         - `#111827` -> `colors.text`
         - `#6B7280` -> `colors.textSecondary`
         - `#9CA3AF` -> `colors.textTertiary`
         - `#E5E7EB` / `#e5e7eb` -> `colors.border`
         - `#10B981` -> `colors.success`
         - `#EF4444` / `#ef4444` -> `colors.error`
         - `#DC2626` -> `colors.error`
         - `#3B82F6` -> `colors.info`
         - `#F97316` -> `colors.warning`
         - `#FEE2E2` -> use tints.red
         - `#ECFDF5` -> use tints.green
         - `#D1D5DB` -> `colors.borderDark`
         - `#A5B4FC` -> `indigo[300]` (for Switch trackColor)
         - `#F9FAFB` -> `colors.backgroundSecondary` (gray[50])
       - Convert StyleSheet.create to use dynamic styles where hex was used. Two approaches depending on complexity:
         - For screens with few hardcoded values: use inline style overrides `[styles.base, { backgroundColor: colors.primary }]`
         - For screens with many hardcoded values (like settings.tsx with ~30): convert to a `createStyles(colors)` factory function that returns StyleSheet.create result, called with `const styles = createStyles(colors)` after useTheme
       - **Settings.tsx specific:** The settings screen has many hardcoded colors. Convert its entire StyleSheet.create to a `createStyles(colors: ThemeColors)` factory function.

    b. **Add skeleton loading state:**
       - Import `SkeletonCard` or `SkeletonList` or `DashboardSkeleton` from `@/components/ui/SkeletonCard`
       - Replace existing `<ActivityIndicator>` loading states with appropriate skeleton component
       - Dashboard: use `DashboardSkeleton`
       - List screens (grades, behavior, earnings): use `SkeletonList` with count matching typical list items
       - Settings: keep simple loading since it loads fast (or use SkeletonList with 3 items)
       - Daily: skeleton for the assessment wizard content area
       - Learn: skeleton for the QOD stats cards

    c. **Add empty state:**
       - Import `EmptyState` from `@/components/ui/EmptyState`
       - When data query returns empty array/null, show EmptyState with appropriate:
         - Dashboard: icon="home-outline", title="Welcome to Centsible Scholar", description="Your dashboard will show your progress here."
         - Grades: icon="school-outline", title="No Grades Yet", description="Grades will appear here once they're entered."
         - Behavior: icon="checkmark-circle-outline", title="No Assessments Yet", description="Complete your daily assessment to see behavior scores."
         - Earnings: icon="wallet-outline", title="No Earnings Yet", description="Earnings will appear once grades are entered."
         - Learn (parent): icon="bulb-outline", title="No Student Data", description="Student progress will appear here."

    d. **Add error state with retry:**
       - Import `ErrorState` from `@/components/ui/ErrorState`
       - When data query has error, show ErrorState with message and refetch as onRetry
       - Pattern: `if (error) return <ErrorState message={error.message} onRetry={refetch} />;`

    e. **Ensure 44pt touch targets:**
       - All TouchableOpacity components must have minHeight: 44 (or equivalent padding that achieves 44pt)
       - Check button heights, list item tap areas, icon buttons
       - Add `minHeight: sizing.touchTarget` where needed (44pt from spacing.ts)

    **CRITICAL ordering in each screen:**
    ```tsx
    if (isLoading) return <SkeletonList />;
    if (error) return <ErrorState message={error.message} onRetry={refetch} />;
    if (!data?.length) return <EmptyState icon="..." title="..." description="..." />;
    return <ActualContent data={data} />;
    ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - No hardcoded hex colors remain in any tab screen or layout file StyleSheet (grep for `#[0-9a-fA-F]{6}` in modified files should return zero or near-zero matches)
    - ThemeProvider wraps app in _layout.tsx
    - Tab bar uses theme colors
    - All 7 tab screens have skeleton loading, empty state, and error state
    - All touch targets are >= 44pt
  </verify>
  <done>
    ThemeProvider wired into app root. All layout files and 7 tab screens migrated from hardcoded colors to useTheme(). Every data-fetching tab screen has skeleton loading, empty state, and error state. 44pt touch targets enforced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate remaining screens (modals, auth, onboarding, daily components) to useTheme</name>
  <files>
    app/(auth)/login.tsx
    app/(auth)/signup.tsx
    app/(auth)/forgot-password.tsx
    app/(auth)/verify-reset-code.tsx
    app/edit-profile.tsx
    app/paywall.tsx
    app/manage-subscription.tsx
    app/student-management.tsx
    app/grade-approval.tsx
    app/term-tracking.tsx
    app/family-meetings.tsx
    app/data-export.tsx
    app/delete-account.tsx
    app/(onboarding)/welcome.tsx
    app/(onboarding)/profile.tsx
    app/(onboarding)/how-it-works.tsx
    app/(onboarding)/celebration.tsx
    app/(onboarding)/index.tsx
    src/components/daily/QODStep.tsx
    src/components/daily/BehaviorStep.tsx
    src/components/daily/CompletionCelebration.tsx
  </files>
  <action>
    Migrate all remaining screen files to use `useTheme()` instead of hardcoded hex colors. This is systematic, mechanical work applying the same pattern from Task 1 to the rest of the app.

    **For each file:**
    1. Add `import { useTheme } from '@/theme';` (adjust relative path as needed -- screens in app/ use `../../src/theme` or `@/theme` depending on alias config)
    2. Add `const { colors } = useTheme();` at top of component
    3. Replace hardcoded hex colors using the same mapping from Task 1:
       - `#4F46E5` -> `colors.primary`
       - `#EEF2FF` -> `colors.primaryLight`
       - `#F3F4F6` -> `colors.backgroundSecondary`
       - `#fff`/`#ffffff` -> `colors.background` or `colors.card` or `colors.textInverse`
       - `#111827` -> `colors.text`
       - `#6B7280` -> `colors.textSecondary`
       - `#9CA3AF` -> `colors.textTertiary`
       - `#E5E7EB` -> `colors.border`
       - `#10B981` -> `colors.success`
       - `#EF4444`/`#DC2626` -> `colors.error`
       - `#3B82F6` -> `colors.info`
       - `#F97316` -> `colors.warning`
       - Any other hex -> find closest theme token
    4. For screens with heavy inline styles, convert to `createStyles(colors)` factory pattern
    5. Ensure 44pt minimum touch targets on all interactive elements

    **Screen-specific notes:**

    - **Auth screens (login, signup, forgot-password, verify-reset-code):**
      These are outside the tab navigator but still inside ThemeProvider. They have ~45 hardcoded values total. Important: these screens have their own layout backgrounds (often white or light gray) and primary-colored buttons.

    - **Paywall (paywall.tsx):**
      Heavy styling with plan cards, billing toggle, pricing text. Convert all hardcoded colors. Keep the current visual design, just source colors from theme.

    - **Manage subscription (manage-subscription.tsx):**
      Similar to paywall. Green success colors for active status, etc.

    - **Student management (student-management.tsx):**
      Student cards with status colors. Use theme semantic colors.

    - **Onboarding screens (welcome, how-it-works, profile, celebration):**
      These are seen once and have brand-heavy styling. Convert hardcoded indigo/purple to theme primary. Keep the celebratory feel.

    - **Daily components (QODStep, BehaviorStep, CompletionCelebration):**
      These are components, not screens, but still have hardcoded colors. Apply same migration. Note: These use the `@/` import alias already.

    - **Data export and delete-account screens (from Plans 02/03):**
      If these were created with hardcoded colors, migrate them to useTheme() as well. If Plan 01 finishes before Plans 02/03 execute, those plans may already use useTheme -- but verify and fix if not.

    **After migration, verify no hardcoded colors remain:**
    Run a grep across all modified files for hex color patterns. The only acceptable remaining hex values are:
    - Shadow colors (`shadowColor: '#000'`) -- these are platform-level and don't change for dark mode (shadow is always black)
    - rgba values for overlays (`rgba(0, 0, 0, 0.5)`) -- acceptable for modal overlays
    - Colors defined IN the theme files themselves (colors.ts)

    **Do NOT modify:**
    - `src/theme/colors.ts` (source of truth for color values)
    - `src/theme/spacing.ts`, `src/theme/typography.ts` (no hardcoded colors)
    - Any file in `node_modules/` or `supabase/functions/`
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Grep for hardcoded hex colors in app/ and src/components/ directories shows zero matches (excluding shadowColor '#000' and rgba patterns)
    - All modified files import and use useTheme()
    - No `import { colors } from` static imports remain (except in theme/ files themselves and backward-compat code)
    - All touch targets >= 44pt
  </verify>
  <done>
    Every screen and component in the app uses useTheme() for colors. Zero hardcoded hex color values remain outside of theme definition files and shadow/rgba exceptions. The entire app is dark-mode-ready through the ThemeContext system.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add loading/error/empty states to modal and secondary screens</name>
  <files>
    app/edit-profile.tsx
    app/student-management.tsx
    app/grade-approval.tsx
    app/term-tracking.tsx
    app/family-meetings.tsx
    app/manage-subscription.tsx
  </files>
  <action>
    Add skeleton loading, error state with retry, and empty state to all remaining data-fetching screens that were not covered in Task 1 (which handled the 7 tab screens).

    **For each screen that fetches data (uses React Query hooks):**

    1. **Replace ActivityIndicator with appropriate skeleton:**
       - `edit-profile.tsx`: Simple form skeleton (3-4 input field skeletons)
       - `student-management.tsx`: SkeletonList with count=3 for student cards
       - `grade-approval.tsx`: SkeletonList with count=3 for pending approvals
       - `term-tracking.tsx`: SkeletonCard for term overview + SkeletonList for term list
       - `family-meetings.tsx`: SkeletonList with count=2 for meeting cards
       - `manage-subscription.tsx`: SkeletonCard for subscription status card

    2. **Add ErrorState with retry:**
       - Import ErrorState from `@/components/ui/ErrorState`
       - When query has error: `if (error) return <ErrorState message={error.message} onRetry={refetch} />;`
       - Wrap in SafeAreaView or container with proper background

    3. **Add EmptyState where appropriate:**
       - `student-management.tsx`: icon="people-outline", title="No Students", description="Add your first student to get started!", actionLabel="Add Student", onAction=handleAdd
       - `grade-approval.tsx`: icon="checkmark-done-outline", title="All Caught Up", description="No grades pending approval."
       - `term-tracking.tsx`: icon="calendar-outline", title="No Terms Set Up", description="Configure your first school term to get started."
       - `family-meetings.tsx`: icon="people-circle-outline", title="No Meetings Yet", description="Schedule your first family meeting to discuss finances."
       - `manage-subscription.tsx`: typically always has data (subscription status), but handle null case
       - `edit-profile.tsx`: always has profile data, no empty state needed

    4. **Ordering pattern (same as tab screens):**
       ```tsx
       if (isLoading) return <SkeletonComponent />;
       if (error) return <ErrorState message={error.message} onRetry={refetch} />;
       if (!data) return <EmptyState ... />;
       return <Content data={data} />;
       ```

    5. **Ensure consistent container backgrounds:**
       All screens should use `colors.backgroundSecondary` (the light gray) as the base background, matching the tab screens' pattern.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - All 6 modal/secondary screens have skeleton loading states (no ActivityIndicator spinners remain)
    - All 6 screens have ErrorState with retry on fetch errors
    - Appropriate screens have EmptyState with helpful messages and action buttons
    - Loading -> Error -> Empty -> Content ordering followed consistently
  </verify>
  <done>
    All data-fetching screens in the app (tabs + modals + secondary) have consistent skeleton loading, error state with retry, and empty state with helpful guidance. No ActivityIndicator loading spinners remain anywhere in the app.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. `grep -r '#[0-9a-fA-F]\{6\}' app/ src/components/ --include='*.tsx' | grep -v shadowColor | grep -v 'rgba' | wc -l` returns 0 (no hardcoded colors outside shadow/rgba)
3. ThemeProvider wraps the app in root _layout.tsx
4. All screens use `useTheme()` hook for colors
5. All data-fetching screens show skeleton loading (no ActivityIndicator)
6. All data-fetching screens show EmptyState when no data
7. All data-fetching screens show ErrorState with retry on errors
8. All touch targets >= 44pt (spot-check buttons, list items)
9. Tab bar uses theme tokens for active/inactive colors
</verification>

<success_criteria>
- Zero hardcoded hex colors in screen files (excluding shadow/rgba)
- ThemeProvider at app root enables dark mode switching
- All layout files (root, tabs, auth, onboarding) use theme colors for headers and tab bars
- Every data-fetching screen follows skeleton -> error -> empty -> content pattern
- Friendly empty states guide users (not just "no data")
- Error states have retry buttons for self-service recovery
- 44pt minimum touch targets on all interactive elements
- App is visually consistent: same spacing, typography, and color tokens across all 25+ screens
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-management-ui-polish/06-04-SUMMARY.md`
</output>
